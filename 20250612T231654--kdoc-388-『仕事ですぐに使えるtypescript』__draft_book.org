:properties:
:ID: 20250612T231654
:mtime:    20250624003527
:ctime:    20250612231658
:end:
#+title:      KDOC 388: 『仕事ですぐに使えるTypeScript』
#+date:       [2025-06-12 Thu 23:16]
#+filetags:   :draft:book:
#+identifier: 20250612T231654

# (kd/denote-kdoc-rename)
# (denote-rename-file-using-front-matter (buffer-file-name) 0)
# (save-excursion (while (re-search-backward ":draft" nil t) (replace-match "")))
# (flush-lines "^\\#\s.+?")

# ====ポリシー。
# 1ファイル1アイデア。
# 1ファイルで内容を完結させる。
# 常にほかのエントリとリンクする。
# 自分の言葉を使う。
# 参考文献を残しておく。
# 文献メモの場合は、感想と混ぜないこと。1つのアイデアに反する
# ツェッテルカステンの議論に寄与するか。それで本を書けと言われて書けるか
# 頭のなかやツェッテルカステンにある問いとどのようにかかわっているか
# エントリ間の接続を発見したら、接続エントリを追加する。カード間にあるリンクの関係を説明するカード。
# アイデアがまとまったらアウトラインエントリを作成する。リンクをまとめたエントリ。
# エントリを削除しない。古いカードのどこが悪いかを説明する新しいカードへのリンクを追加する。
# 恐れずにカードを追加する。無意味の可能性があっても追加しておくことが重要。
# 個人の感想・意思表明ではない。事実や書籍情報に基づいている

# ====永久保存メモのルール。
# 自分の言葉で書く。
# 後から読み返して理解できる。
# 他のメモと関連付ける。
# ひとつのメモにひとつのことだけを書く。
# メモの内容は1枚で完結させる。
# 論文の中に組み込み、公表できるレベルである。

# ====水準を満たす価値があるか。
# その情報がどういった文脈で使えるか。
# どの程度重要な情報か。
# そのページのどこが本当に必要な部分なのか。
# 公表できるレベルの洞察を得られるか

# ====フロー。
# 1. 「走り書きメモ」「文献メモ」を書く
# 2. 1日1回既存のメモを見て、自分自身の研究、思考、興味にどのように関係してくるかを見る
# 3. 追加すべきものだけ追加する

* この文書のステータス
:LOGBOOK:
CLOCK: [2025-12-21 Sun 21:11]--[2025-12-21 Sun 21:36] =>  0:25
CLOCK: [2025-06-21 Sat 23:00]--[2025-06-21 Sat 23:25] =>  0:25
:END:
- 作成
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))
- レビュー
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))

# チェックリスト ================
# 関連をつけた。
# タイトルがフォーマット通りにつけられている。
# 内容をブラウザに表示して読んだ(作成とレビューのチェックは同時にしない)。
# 文脈なく読めるのを確認した。
# おばあちゃんに説明できる。
# いらない見出しを削除した。
# タグを適切にした。
# すべてのコメントを削除した。
* 概要
# 本文(見出しも設定する)

[[https://future-architect.github.io/typescript-guide/typescript-guide.pdf][仕事ですぐに使えるTypeScript]]は、TypeScriptの入門本。

* メモ

- Babelを使用して最新のJavaScriptから互換性の高いJavaScriptへの変換を行う(p5)
- (疑問)型定義 *ファイル* が同時生成できて無駄がない、とあるが、別個のファイルなのだろうか(p5)
  - ゼロからTypeScriptでいけば、型定義ファイルは自動生成される(p6)
- TypeScriptの型はほかの型付き言語と比べて柔軟である。型システムがプログラミングのサポートの機能しかなく、静的なメモリ配置まで面倒を見るような言語とは異なる(p21)
- numberは2進数で表した数値表現なので、0.2+0.1などのようにきれいに2進数で表せない数値は誤差が出てしまう(p28)
- Javascriptはエンコード方式としてUTF-16を採用している(p32)
- Reactは1行のreturn文のなかで仮想DOMという巨大なJavaScriptオブジェクトを生成する。そこで参考演算子が役立つ(p57)
- TypeScriptのソースコードはあくまでもJavaScriptに変換されてから実行される。TypeScriptのコンパイラが持つインターフェースやtypeなど固有の型情報はランタイムには存在しない。そのため「このオブジェクトがこのインターフェースを持つとき」という実行文はほかの言語のようにそのまま実行できない(p68)
- TypeScriptはそれを解決するために型ガードという機能が実装されている。実行時の文脈を解析し、型の選択肢を適切に絞り込んでいく。コンパイラはtypeofやinstanceofなどを見て型ガードと判定する、という(p68)
- (感想)なぜtypeofは文字列で返すのだろうか。型ガードがある理由と同じようにランタイムにまつわるものだろうか。TypeScriptの層で吸収できそうにも見える
- 型ガードではTypeScriptのコンパイラだけが知っている情報は扱えない。JavaScriptとして実行時にアクセスできる情報を使って、booleanを返す必要がある(p70)
- 型アサーションは実行文ではなく、あくまでコンパイラの持つ型情報を上書きするものである。型ガードと異なり、実行時には一切参照しない(p70)
- 従来のJavaScriptは関数の使い勝手がよかったいっぽうで、言語の他の機能は少なかった。関数を多用したテクニックが多くあった(p75)
- 実行時の親子関係ではなく、ソースコードという定義時の親子関係を元にしてスコープが決定されることをレキシカルスコープという(p82)
  - (感想)今まで見た説明のなかでもっともわかりやすい説明
  - (感想)逆に実行時に決まるのがダイナミックスコープ
- 自分が定義された場所の外の変数を束縛した関数をクロージャという(p82)
- ~this~ は変数ではなく、特別な識別子である。レキシカルスコープで束縛できない。クロージャかつ、 ~this~ への束縛ができる新文法としてアロー関数が追加された。無名関数をコールバック関数に渡そうとすると ~this~ がわからなくなってしまう問題がある。アロー関数を使うとその関数が定義された場所の ~this~ の保持までセットで行う。アロー関数が出る以前は ~this~ がなくなってしまうため別の名前に退避させていた(p82)
- TypeScriptのDateは数字に毛の生えたようなものである、という(p88)
- ブラウザにはperformance.now()という高精度タイマーがあったが、セキリュティの懸念で現在は精度が落とされていてDate.now()とあまり変わらない(p88)
  - (感想)どういうことなのだろう
- ブラウザはユーザインターフェースであるため、ユーザの利用環境のタイムゾーン情報を持っている。しかし多くのユーザの情報を同時に扱うサーバではタイムゾーン情報も含めて扱うのは手間がかかる。なので、サーバーでは常にエポック時刻で扱うようにする。クライアントがサーバに送信するときはエポック時刻にして送信する。クライアント側でローカル時刻化する。を指針にするとよい(p89)
- スリープのような、実行を行の途中で止めるような処理は基本的にもっていなかった。10秒後に実行される関数を登録する、といった処理が提供され、「10秒止める」という処理を書く機能は提供されなかった。JavaScriptは伝統的に、ホストとなる環境(ブラウザ)のなかで実行される、アプリケーション言語として使われることが多かった。ホスト側のアプリケーションから見て長時間ブロックされるなどの行儀の悪い動きをするのが忌避されてきた(p123)
- ブラウザでは数々のHTMLのインタラクション、タイマーなどのイベントに対してあらかじめ登録しておいたイベントハンドラの関数が呼ばれる、というモデルを採用している(p123)
- 現在見かける非同期処理の書き方は3種類ある(p123)
  - コールバック
  - Promise
  - async / await
- 基本的にループ内のawaitは警戒すべきコードである。ループごとに待つから(p128)
  - Promise.all()を使うと、同時実行して引数の配列すべての処理が終わるのを待つ、を表現できる
- 以前のJavaScriptは公式には複数のファイルに分割してコーディングする方法を提供していなかった。当初はClosure Compiler、ライブラリごとの固有のファイル結合ツール、require.jsなどを使っていた。そのあとNode.jsが登場しCommonJSというサーバーサイドJavaScriptのための仕様から取り込まれたモジュールシステムがデファクトスタンダードとなった。ブラウザからは利用しにくい仕様だったため、ブラウザからも利用できるES2015 modulesが仕様化された(p143)
- ES2015 modules が仕様化されたといっても、これだけでは完結しない。通常はダウンロードをまとめて行うために事前にバンドラーツールで1ファイルにまとめつつ最適化する。ライブラリの流通の仕組みがNode.jsのエコシステムであるnpmjs.orgで行われることもあって、ライブラリの多くがCommonJS形式で提供されている。なのでCommonJSとも連携が必要である(p151)
- TypeScriptはインポートしたものが型だけの場合に、出力からそのインポート文を丸ごと排除する。なので副作用のコードは実行されない(p152)
- 副作用なく型のインポートのみを許容する構文がある(p153)
- 型による実装の分岐はできない。JavaScriptにないことはできない(p162)

* 関連
# 関連するエントリ。なぜ関連させたか理由を書く。意味のあるつながりを意識的につくる。
# - この事実は自分のこのアイデアとどう整合するか。
# - この現象はあの理論でどう説明できるか。
# - ふたつのアイデアは互いに矛盾するか、互いを補っているか。
# - いま聞いた内容は以前に聞いたことがなかったか。
# - メモ y についてメモ x はどういう意味か。
# - 対立する
# - 修正する
# - 補足する
# - 付け加えるもの
# - アイデア同士を組み合わせて新しいものを生み出せないか
# - どんな疑問が浮かんだか
なし。
